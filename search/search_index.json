{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyWars A public topic consumer for Chat Wars ... with steroids \ud83d\ude80 Motivations \ud83e\udd16 Build a bot? \ud83d\udc65 Help comunity? \ud83d\ude80 Personal training? \u2604 Quick start from PyWars import * app = Client () @app . agent ( Deal ) async def deals ( stream : Stream [ Deal ]): async for deal in stream : print ( deal ) app . run () \ud83d\udcda Overview Dummy client creation from PyWars import Client app = Client () This will create a client with an autogenerated id for chat wars v2 api Specifiying client version from PyWars import Client app = Client ( version = Client . Version . CW3 ) This will create a client for chat wars v3 api Adding agents from PyWars import * app = Client () @app . agent ( Deal ) async def deals ( stream : Stream [ Deal ]): async for deal in stream : print ( deal ) app . run () The Client.agent method recieves an allowed record. The allowed records are: Deal for cw*-deals topic Duel for cw*-duels topic Offer for cw*-offers topic SexDigest for cw*-sex_digest topic YellowPage for cw*-yellow_pages topic AuctionDigest for cw*-au_digest topic Adding timers from PyWars import * app = Client () procesed_deals = 0 @app . agent ( Deal ) async def deals ( stream : Stream [ Deal ]): async for deal in stream : procesed_deals += 1 @app . timer ( 60 ) async def print_procesed (): print ( procesed_deals ) procesed_deals = 0 app . run () A timer is a courutine that is triggered every n seconds in the previous examples we used 60 seconds . Using executions loops from PyWars import * import asyncio app = Client ( loop = asyncio . get_event_loop ()) @app . agent ( Deal ) async def deals ( stream : Stream [ Deal ]): async for deal in stream : print ( deal ) try : app . start () finally : app . stop () The magical start and stop methods were thought to run and stop client with his execution loop smootly Bulking from PyWars import * app = Client () @app . agent ( Deal ) async def deals ( stream : Stream [ Deal ]): async for bulk in stream . take ( 100 , 10 ): print ( bulk ) app . run () A bulk is just the use of Stream.take method from faust . It will try to take bulks of 100 objetcs, in case that it can\u00b4t return the 100 objects its going to wait for 10 seconds and return any amount gathered in that time. For extended documentation see for the docs page.","title":"Home"},{"location":"#pywars","text":"A public topic consumer for Chat Wars ... with steroids","title":"PyWars"},{"location":"#motivations","text":"\ud83e\udd16 Build a bot? \ud83d\udc65 Help comunity? \ud83d\ude80 Personal training?","title":"\ud83d\ude80 Motivations"},{"location":"#quick-start","text":"from PyWars import * app = Client () @app . agent ( Deal ) async def deals ( stream : Stream [ Deal ]): async for deal in stream : print ( deal ) app . run ()","title":"\u2604 Quick start"},{"location":"#overview","text":"","title":"\ud83d\udcda Overview"},{"location":"#dummy-client-creation","text":"from PyWars import Client app = Client () This will create a client with an autogenerated id for chat wars v2 api","title":"Dummy client creation"},{"location":"#specifiying-client-version","text":"from PyWars import Client app = Client ( version = Client . Version . CW3 ) This will create a client for chat wars v3 api","title":"Specifiying client version"},{"location":"#adding-agents","text":"from PyWars import * app = Client () @app . agent ( Deal ) async def deals ( stream : Stream [ Deal ]): async for deal in stream : print ( deal ) app . run () The Client.agent method recieves an allowed record. The allowed records are: Deal for cw*-deals topic Duel for cw*-duels topic Offer for cw*-offers topic SexDigest for cw*-sex_digest topic YellowPage for cw*-yellow_pages topic AuctionDigest for cw*-au_digest topic","title":"Adding agents"},{"location":"#adding-timers","text":"from PyWars import * app = Client () procesed_deals = 0 @app . agent ( Deal ) async def deals ( stream : Stream [ Deal ]): async for deal in stream : procesed_deals += 1 @app . timer ( 60 ) async def print_procesed (): print ( procesed_deals ) procesed_deals = 0 app . run () A timer is a courutine that is triggered every n seconds in the previous examples we used 60 seconds .","title":"Adding timers"},{"location":"#using-executions-loops","text":"from PyWars import * import asyncio app = Client ( loop = asyncio . get_event_loop ()) @app . agent ( Deal ) async def deals ( stream : Stream [ Deal ]): async for deal in stream : print ( deal ) try : app . start () finally : app . stop () The magical start and stop methods were thought to run and stop client with his execution loop smootly","title":"Using executions loops"},{"location":"#bulking","text":"from PyWars import * app = Client () @app . agent ( Deal ) async def deals ( stream : Stream [ Deal ]): async for bulk in stream . take ( 100 , 10 ): print ( bulk ) app . run () A bulk is just the use of Stream.take method from faust . It will try to take bulks of 100 objetcs, in case that it can\u00b4t return the 100 objects its going to wait for 10 seconds and return any amount gathered in that time. For extended documentation see for the docs page.","title":"Bulking"},{"location":"ex.printing/","text":"A dummy example of printing all We import all basic stuff and build a dummy client for cw2 api consumtion from PyWars import * app = Client () We define an agent to process deals @app . agent ( Deal ) # this decorator define wath kind of topic we are specting for consume async def deals ( stream : Stream [ Deal ], ): # as we consume 'deals' topic we recieve a stream of deals async for deal in stream : # we itterate over the deals print ( deal ) # and we print every one of them From now on all it will be more of the same implementation @app . agent ( Offer ) async def offers ( stream : Stream [ Offer ]): async for offer in stream : print ( offer ) @app . agent ( Duel ) async def duels ( stream : Stream [ Duel ]): async for duel in stream : print ( duel ) @app . agent ( SexDigest ) async def sexdigest ( stream : Stream [ SexDigest ]): async for sd in stream : print ( sd ) @app . agent ( YellowPage ) async def yellow_pages ( stream : Stream [ YellowPage ]): async for yp in stream : print ( yp ) @app . agent ( AuctionDigest ) async def auctions ( stream : Stream [ AuctionDigest ]): async for adigest in stream : print ( adigest ) Now we start to process and printing, easy and dummy app . run ()","title":"Printing"},{"location":"ex.printing/#a-dummy-example-of-printing-all","text":"We import all basic stuff and build a dummy client for cw2 api consumtion from PyWars import * app = Client () We define an agent to process deals @app . agent ( Deal ) # this decorator define wath kind of topic we are specting for consume async def deals ( stream : Stream [ Deal ], ): # as we consume 'deals' topic we recieve a stream of deals async for deal in stream : # we itterate over the deals print ( deal ) # and we print every one of them From now on all it will be more of the same implementation @app . agent ( Offer ) async def offers ( stream : Stream [ Offer ]): async for offer in stream : print ( offer ) @app . agent ( Duel ) async def duels ( stream : Stream [ Duel ]): async for duel in stream : print ( duel ) @app . agent ( SexDigest ) async def sexdigest ( stream : Stream [ SexDigest ]): async for sd in stream : print ( sd ) @app . agent ( YellowPage ) async def yellow_pages ( stream : Stream [ YellowPage ]): async for yp in stream : print ( yp ) @app . agent ( AuctionDigest ) async def auctions ( stream : Stream [ AuctionDigest ]): async for adigest in stream : print ( adigest ) Now we start to process and printing, easy and dummy app . run ()","title":"A dummy example of printing all"},{"location":"ex.telegram/","text":"Example of how use it with Pyrogram We start importing pyrogram client and our PyWars stuff from pyrogram import Client as Telegram from PyWars import * We create a telegram and a chat wars client telegram = Telegram ( \"my_account\" ) chat_wars = Client ( loglevel = \"info\" , ) A bucket of deals bucket = {} Now we start the agents creation for fill a bucket @chat_wars . agent ( Deal ) async def bucket_builder ( stream : Stream [ Deal ]): async for deal in stream : msg = ( f \" { deal . buyerName } buy { deal . qty } from { deal . sellerName } a { deal . price } $\" ) if deal . item in bucket : bucket [ deal . item ] . append ( msg ) else : bucket [ deal . item ] = [ msg ] And a timer for post the bucket every 10 seconds @chat_wars . timer ( 10 ) async def post_deals (): me = await telegram . get_me () And late we build a post for that bucket post = \"\" for item , lines in bucket . items (): post += f \" { item } : \\n\\n \" post += \" \\n \" . join ( lines ) post += \" \\n \" if post : await telegram . send_message ( me . id , post ) bucket . clear () telegram . start () chat_wars . run ()","title":"Pyrogram"},{"location":"ex.telegram/#example-of-how-use-it-with-pyrogram","text":"We start importing pyrogram client and our PyWars stuff from pyrogram import Client as Telegram from PyWars import * We create a telegram and a chat wars client telegram = Telegram ( \"my_account\" ) chat_wars = Client ( loglevel = \"info\" , ) A bucket of deals bucket = {} Now we start the agents creation for fill a bucket @chat_wars . agent ( Deal ) async def bucket_builder ( stream : Stream [ Deal ]): async for deal in stream : msg = ( f \" { deal . buyerName } buy { deal . qty } from { deal . sellerName } a { deal . price } $\" ) if deal . item in bucket : bucket [ deal . item ] . append ( msg ) else : bucket [ deal . item ] = [ msg ] And a timer for post the bucket every 10 seconds @chat_wars . timer ( 10 ) async def post_deals (): me = await telegram . get_me () And late we build a post for that bucket post = \"\" for item , lines in bucket . items (): post += f \" { item } : \\n\\n \" post += \" \\n \" . join ( lines ) post += \" \\n \" if post : await telegram . send_message ( me . id , post ) bucket . clear () telegram . start () chat_wars . run ()","title":"Example of how use it with Pyrogram"},{"location":"pw.__init__/","text":"PyWars We start from a straigth forward idea: use a client and a set of types for doing some stream processing over stream of those types. The client from .client import Client The types from .types import ( Deal , Offer , Duelist , Duel , Item , SexDigest , OfferItem , Specialization , Shop , YellowPage , AuctionDeal , AuctionDigest , ) The stream from faust import Stream I am not a hardcore player of chat war (CW) but i am a curious person and I was building some bots that help to play chat wars until i met gecko and lycaon. But after some research in my developing fever I found that the CW API has only an old client in GO but nothing that consume from actual kafka streams in a straigth forward manner. This is a client for public api based on Chat Wars API docs and some usefull examples from sixcross repo. Note This implementation will not behold any rpc call to private API but in the future I want to do that and in farther future merge both to have a complete functional overpowered API","title":"PyWars.__init__"},{"location":"pw.__init__/#pywars","text":"We start from a straigth forward idea: use a client and a set of types for doing some stream processing over stream of those types. The client from .client import Client The types from .types import ( Deal , Offer , Duelist , Duel , Item , SexDigest , OfferItem , Specialization , Shop , YellowPage , AuctionDeal , AuctionDigest , ) The stream from faust import Stream I am not a hardcore player of chat war (CW) but i am a curious person and I was building some bots that help to play chat wars until i met gecko and lycaon. But after some research in my developing fever I found that the CW API has only an old client in GO but nothing that consume from actual kafka streams in a straigth forward manner. This is a client for public api based on Chat Wars API docs and some usefull examples from sixcross repo. Note This implementation will not behold any rpc call to private API but in the future I want to do that and in farther future merge both to have a complete functional overpowered API","title":"PyWars"},{"location":"pw.client/","text":"Note The client We import core class and modules here import asyncio from enum import Enum from functools import cache , cached_property from pathlib import Path from typing import Any , Callable , Coroutine , Tuple , Union later the faust related objects from faust import App , Worker , Record , uuid and at last all defined types from .types import Deal , Duel , Offer , SexDigest , YellowPage , AuctionDigest The Client The client is just an object composition using faust class Client : We use this to know what models and kafka topics are allowed and how are related. allowed_records = { Deal : \"deals\" , Duel : \"duels\" , Offer : \"offers\" , SexDigest : \"sex_digest\" , YellowPage : \"yellow_pages\" , AuctionDigest : \"au_digest\" , } and this to define versions of chat wars class Version ( Enum ): CW2 = \"cw2\" CW3 = \"cw3\" The Client. init method can recieve id: just the client id version: client version broker: kafka address or broker loop: execution loop debug: for debuging with aiomonitor loglevel: the level of expecting logging info This initialice a kafka consumer (carefull with this is just a consumer ) with a provided or self generated id that consume from a provided or default (cw2) chat wars version topics. This consumer listen from a provided broker and is executed in a provided or self generated loop . def __init__ ( self , id : str = None , version : \"Client.Version\" = None , broker : str = \"kafka://digest-api.chtwrs.com:9092\" , work_dir : Union [ str , Path ] = \"./.fchatwars\" , loop : asyncio . AbstractEventLoop = None , debug : bool = False , loglevel : Union [ str , int ] = \"warning\" , ) -> None : self . _loop = loop if loop is not None else asyncio . get_event_loop () self . _version = version if version is not None else self . Version . CW2 self . _debug = debug self . _logleve = loglevel self . _app = App ( id = uuid () if id is None else id , broker_consumer = broker , topic_disable_leader = True , web_enabled = False , ) self . _workdir = Path ( work_dir ) self . _workdir . mkdir ( exist_ok = True ) The properties are straigth forward so ... no explanations are needed @property def loop ( self ) -> asyncio . AbstractEventLoop : return self . _loop @property def workdir ( self ) -> Path : return self . _workdir @property def version ( self ) -> \"Client.Version\" : return self . _version @property def debug ( self ) -> bool : return self . _debug @property def loglevel ( self ) -> Union [ str , int ]: return self . _logleve This is a faust topic builder with some cache ( just for internal use ) @cache def _topic ( self , record : Record ): topic_name = f \" { self . version . value } - { self . allowed_records [ record ] } \" return self . _app . topic ( topic_name , value_type = record ) Partial exposition of the faust agent decorator, an agent is (in this case) an asyncronous stream consumer def agent ( self , record ): assert record in self . allowed_records , \"This is not an allowed Chat Wars Record\" return self . _app . agent ( self . _topic ( record )) This is a very straigth forward exposition of faust timer function def timer ( self , seconds ): return self . _app . timer ( interval = seconds ) Return a function to start and a function to stop it (not for external use) @cached_property def _driven_functions ( self ) -> Tuple [ Callable , Callable ]: worker = Worker ( self . _app , loop = self . loop , debug = self . debug , loglevel = self . loglevel , workdir = self . workdir , quiet = True , redirect_stdouts = False , ) # We remove or preset not important setting when we create the worker worker . spinner = None # Removing anoying spinner return ( lambda : self . loop . run_until_complete ( worker . start ()), worker . stop_and_shutdown , ) This method starts the app execution loop def start ( self ): return self . _driven_functions [ 0 ]() This method stops the app execution loop def stop ( self ): return self . _driven_functions [ 1 ]() This method run the app in a fancy controlled way def run ( self ): try : self . start () finally : self . stop () A method for cli use ... if you want def cli ( self ): return self . _app . main () Note I have some doubts about let rockdb faust integration or not. I\u00b4m going to let it out for now. Now we are ready for some testing \ud83d\udc4b","title":"PyWars.client"},{"location":"pw.client/#the-client","text":"The client is just an object composition using faust class Client : We use this to know what models and kafka topics are allowed and how are related. allowed_records = { Deal : \"deals\" , Duel : \"duels\" , Offer : \"offers\" , SexDigest : \"sex_digest\" , YellowPage : \"yellow_pages\" , AuctionDigest : \"au_digest\" , } and this to define versions of chat wars class Version ( Enum ): CW2 = \"cw2\" CW3 = \"cw3\" The Client. init method can recieve id: just the client id version: client version broker: kafka address or broker loop: execution loop debug: for debuging with aiomonitor loglevel: the level of expecting logging info This initialice a kafka consumer (carefull with this is just a consumer ) with a provided or self generated id that consume from a provided or default (cw2) chat wars version topics. This consumer listen from a provided broker and is executed in a provided or self generated loop . def __init__ ( self , id : str = None , version : \"Client.Version\" = None , broker : str = \"kafka://digest-api.chtwrs.com:9092\" , work_dir : Union [ str , Path ] = \"./.fchatwars\" , loop : asyncio . AbstractEventLoop = None , debug : bool = False , loglevel : Union [ str , int ] = \"warning\" , ) -> None : self . _loop = loop if loop is not None else asyncio . get_event_loop () self . _version = version if version is not None else self . Version . CW2 self . _debug = debug self . _logleve = loglevel self . _app = App ( id = uuid () if id is None else id , broker_consumer = broker , topic_disable_leader = True , web_enabled = False , ) self . _workdir = Path ( work_dir ) self . _workdir . mkdir ( exist_ok = True ) The properties are straigth forward so ... no explanations are needed @property def loop ( self ) -> asyncio . AbstractEventLoop : return self . _loop @property def workdir ( self ) -> Path : return self . _workdir @property def version ( self ) -> \"Client.Version\" : return self . _version @property def debug ( self ) -> bool : return self . _debug @property def loglevel ( self ) -> Union [ str , int ]: return self . _logleve This is a faust topic builder with some cache ( just for internal use ) @cache def _topic ( self , record : Record ): topic_name = f \" { self . version . value } - { self . allowed_records [ record ] } \" return self . _app . topic ( topic_name , value_type = record ) Partial exposition of the faust agent decorator, an agent is (in this case) an asyncronous stream consumer def agent ( self , record ): assert record in self . allowed_records , \"This is not an allowed Chat Wars Record\" return self . _app . agent ( self . _topic ( record )) This is a very straigth forward exposition of faust timer function def timer ( self , seconds ): return self . _app . timer ( interval = seconds ) Return a function to start and a function to stop it (not for external use) @cached_property def _driven_functions ( self ) -> Tuple [ Callable , Callable ]: worker = Worker ( self . _app , loop = self . loop , debug = self . debug , loglevel = self . loglevel , workdir = self . workdir , quiet = True , redirect_stdouts = False , ) # We remove or preset not important setting when we create the worker worker . spinner = None # Removing anoying spinner return ( lambda : self . loop . run_until_complete ( worker . start ()), worker . stop_and_shutdown , ) This method starts the app execution loop def start ( self ): return self . _driven_functions [ 0 ]() This method stops the app execution loop def stop ( self ): return self . _driven_functions [ 1 ]() This method run the app in a fancy controlled way def run ( self ): try : self . start () finally : self . stop () A method for cli use ... if you want def cli ( self ): return self . _app . main () Note I have some doubts about let rockdb faust integration or not. I\u00b4m going to let it out for now. Now we are ready for some testing \ud83d\udc4b","title":"The Client"},{"location":"pw.ty.__init__/","text":"Note This module holds all python code that define Chat Wars api topics objetcs in a pythonic way We import that objects as a shortcut here from .types import ( Deal , Offer , Duelist , Duel , Item , SexDigest , OfferItem , Shop , YellowPage , AuctionDeal , AuctionDigest , Specialization , )","title":"PyWars.types.__init__"},{"location":"pw.ty.digests/","text":"Note This module constain a new abstract type of faust record to process some data from CW api We start importing some typing stuff from typing import Generic , TypeVar and the faust related objects and types from faust import Record from faust.serializers import codecs then we import our custom codec serializer from .._codec import digest and we register that codec (to be loaded for every package or script or app that use this) codecs . register ( \"digest\" , digest ()) We use a generic var for generic use in digests T = TypeVar ( \"T\" ) and then we build digest that represent any 'response in list shape' throwed by the api class Digest ( Record , Generic [ T ], serializer = \"digest\" , abstract = True ): digest : list [ T ] def __iter__ ( self ): for d in self . digest : yield d def __str__ ( self ) -> str : return str ( self . digest )","title":"PyWars.types.digest"},{"location":"pw.ty.types/","text":"Note A good way to start is defining data models or records related to chat wars kafak topics. We import static typing stuff from typing import Dict , List and faust record from faust import Record and this digest object for processing \"responses as list\" from the api from .digests import Digest The records \ud83e\udd1d Objects on 'cw*-deals' topic class Deal ( Record , serializer = \"json\" ): sellerId : str sellerCastle : str sellerName : str buyerId : str buyerCastle : str buyerName : str item : str qty : int price : int \ud83d\udcb0 Objects on 'cw*-offers' topic class Offer ( Record , serializer = \"json\" ): sellerId : str sellerCastle : str sellerName : str item : str qty : int price : int \u2694 Objects on 'cw*-duels' topic The duelist class Duelist ( Record , serializer = \"json\" ): id : str name : str tag : str castle : str level : int hp : int And the duel class Duel ( Record , serializer = \"json\" ): winner : Duelist loser : Duelist isChallenge : bool isGuildDuel : bool \ud83e\udd11 Objects on 'cw*-sex_digest' topic The items inside the digest list class Item ( Record , serializer = \"json\" ): name : str prices : List [ int ] and the digest class SexDigest ( Digest [ Item ]): pass \ud83d\udecd Objects on 'cw*-yellow_pages' topic The item offered inside the shops class OfferItem ( Record , serializer = \"json\" ): item : str price : int mana : int The specialization record inside 'specializations' if any class Specialization ( Record , serializer = \"json\" ): level : int values : Dict [ str , int ] Now the shop class Shop ( Record , serializer = \"json\" ): kind : str name : str ownerCastle : str ownerName : str ownerTag : str mana : int link : str offers : List [ OfferItem ] especialization : Dict [ str , int ] especializations : Dict [ str , Specialization ] qualityCraftLevel : int maintenanceEnable : bool maintenanceCost : int guildDiscount : int castleDiscount : int And in the end the yellow_page topic definition class YellowPage ( Digest [ Shop ]): pass \ud83d\udece Objects on 'cw*-au_digest' topic A deal or a auction transaction class AuctionDeal ( Record , serializer = \"json\" ): lotId : str itemName : str sellerTag : str sellerName : str quality : str sellerCastle : str condition : str endAt : str # TODO: turn this into datetime using dateutils and faust easing startedAt : str # TODO: turn this into datetime using dateutils and faust easing buyerCastle : str status : str finishedAt : str buyerTag : str buyerName : str price : int stats : Dict [ str , int ] And the auction digest definition class AuctionDigest ( Digest [ AuctionDeal ]): pass","title":"PyWars.types.types"},{"location":"pw.ty.types/#the-records","text":"","title":"The records"},{"location":"pw.ty.types/#objects-on-cw-deals-topic","text":"class Deal ( Record , serializer = \"json\" ): sellerId : str sellerCastle : str sellerName : str buyerId : str buyerCastle : str buyerName : str item : str qty : int price : int","title":"\ud83e\udd1d Objects on 'cw*-deals' topic"},{"location":"pw.ty.types/#objects-on-cw-offers-topic","text":"class Offer ( Record , serializer = \"json\" ): sellerId : str sellerCastle : str sellerName : str item : str qty : int price : int","title":"\ud83d\udcb0 Objects on 'cw*-offers' topic"},{"location":"pw.ty.types/#objects-on-cw-duels-topic","text":"The duelist class Duelist ( Record , serializer = \"json\" ): id : str name : str tag : str castle : str level : int hp : int And the duel class Duel ( Record , serializer = \"json\" ): winner : Duelist loser : Duelist isChallenge : bool isGuildDuel : bool","title":"\u2694 Objects on 'cw*-duels' topic"},{"location":"pw.ty.types/#objects-on-cw-sex_digest-topic","text":"The items inside the digest list class Item ( Record , serializer = \"json\" ): name : str prices : List [ int ] and the digest class SexDigest ( Digest [ Item ]): pass","title":"\ud83e\udd11 Objects on 'cw*-sex_digest' topic"},{"location":"pw.ty.types/#objects-on-cw-yellow_pages-topic","text":"The item offered inside the shops class OfferItem ( Record , serializer = \"json\" ): item : str price : int mana : int The specialization record inside 'specializations' if any class Specialization ( Record , serializer = \"json\" ): level : int values : Dict [ str , int ] Now the shop class Shop ( Record , serializer = \"json\" ): kind : str name : str ownerCastle : str ownerName : str ownerTag : str mana : int link : str offers : List [ OfferItem ] especialization : Dict [ str , int ] especializations : Dict [ str , Specialization ] qualityCraftLevel : int maintenanceEnable : bool maintenanceCost : int guildDiscount : int castleDiscount : int And in the end the yellow_page topic definition class YellowPage ( Digest [ Shop ]): pass","title":"\ud83d\udecd Objects on 'cw*-yellow_pages' topic"},{"location":"pw.ty.types/#objects-on-cw-au_digest-topic","text":"A deal or a auction transaction class AuctionDeal ( Record , serializer = \"json\" ): lotId : str itemName : str sellerTag : str sellerName : str quality : str sellerCastle : str condition : str endAt : str # TODO: turn this into datetime using dateutils and faust easing startedAt : str # TODO: turn this into datetime using dateutils and faust easing buyerCastle : str status : str finishedAt : str buyerTag : str buyerName : str price : int stats : Dict [ str , int ] And the auction digest definition class AuctionDigest ( Digest [ AuctionDeal ]): pass","title":"\ud83d\udece Objects on 'cw*-au_digest' topic"}]}